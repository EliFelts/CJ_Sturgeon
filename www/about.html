<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About This App and Estimation Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="about_files/libs/clipboard/clipboard.min.js"></script>
<script src="about_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="about_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="about_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="about_files/libs/quarto-html/popper.min.js"></script>
<script src="about_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="about_files/libs/quarto-html/anchor.min.js"></script>
<link href="about_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="about_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="about_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="about_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="about_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#page-navigation-and-features" id="toc-page-navigation-and-features" class="nav-link active" data-scroll-target="#page-navigation-and-features">Page Navigation and Features</a>
  <ul class="collapse">
  <li><a href="#explore-fish-detections-page" id="toc-explore-fish-detections-page" class="nav-link" data-scroll-target="#explore-fish-detections-page">Explore Fish Detections Page</a></li>
  <li><a href="#explore-individuals-page" id="toc-explore-individuals-page" class="nav-link" data-scroll-target="#explore-individuals-page">Explore Individuals Page</a></li>
  <li><a href="#deployment-diagnostics-page" id="toc-deployment-diagnostics-page" class="nav-link" data-scroll-target="#deployment-diagnostics-page">Deployment Diagnostics Page</a></li>
  </ul></li>
  <li><a href="#interactive-features" id="toc-interactive-features" class="nav-link" data-scroll-target="#interactive-features">Interactive Features</a></li>
  <li><a href="#panels" id="toc-panels" class="nav-link" data-scroll-target="#panels">Panels</a>
  <ul class="collapse">
  <li><a href="#maps" id="toc-maps" class="nav-link" data-scroll-target="#maps">Maps</a></li>
  <li><a href="#plots" id="toc-plots" class="nav-link" data-scroll-target="#plots">Plots</a></li>
  </ul></li>
  <li><a href="#estimation-methods" id="toc-estimation-methods" class="nav-link" data-scroll-target="#estimation-methods">Estimation Methods</a>
  <ul class="collapse">
  <li><a href="#regional-occupancy" id="toc-regional-occupancy" class="nav-link" data-scroll-target="#regional-occupancy">Regional Occupancy</a></li>
  <li><a href="#depth-distribution" id="toc-depth-distribution" class="nav-link" data-scroll-target="#depth-distribution">Depth Distribution</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">About This App and Estimation Methods</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="page-navigation-and-features" class="level2">
<h2 class="anchored" data-anchor-id="page-navigation-and-features">Page Navigation and Features</h2>
<section id="explore-fish-detections-page" class="level3">
<h3 class="anchored" data-anchor-id="explore-fish-detections-page">Explore Fish Detections Page</h3>
<p>For groups of fish, this page displays regional occupancy expressed in percent of fish hours within given regions, and depth distribution expressed in proportion of time spent at various depth bins. Users can filter on months and years. The years available in the dropdown menu will only include years for which all of the months selected in the month dropdown menu are available.</p>
</section>
<section id="explore-individuals-page" class="level3">
<h3 class="anchored" data-anchor-id="explore-individuals-page">Explore Individuals Page</h3>
<p>For individual fish, explore summary data in Individual Fish Summaries Table. To populate Selection Map, Daily Detection Count, and Daily Median Depth, select an individual in the table. The selection map will show regional occupancy for that individual fish and also points for all receivers it has been detected. The most recent receiver will be highlighted. These points can be clicked to view summaries of that fish’s history at a given location. Daily Detection Count is a stacked bar of daily detections by location for the selected individual. The dashed horizontal line is the maximum number of detections there should be in a day based on the mean ping rate. The blue vertical dashed line is the initial release date, and if the fish has been censored there will be a red vertical dashed line at the censor date. The details of the various reference lines will popup if you hover your mouse over the base of the line (near the bottom for vertical lines and left for horizontal line). For right censored fish, the popup will also indicate the reason the fish was censored (e.g.&nbsp;known mortality, battery life ended, etc.). Daily Median Depth shows daily points for the median depth; hovering the mouse over any of these points will show a popup of summaries for that day including the date, min, median, max and total number of detections. Points will appear red if they occur at depths greater than the specified sensor range of the transmitter. The blue vertical dashed line is the initial release date just as in the Daily Detection Count plot.</p>
</section>
<section id="deployment-diagnostics-page" class="level3">
<h3 class="anchored" data-anchor-id="deployment-diagnostics-page">Deployment Diagnostics Page</h3>
<p>The initial map on the left panel will show all locations where receivers have been deployed with active locations shown in blue. Locations can be selected by clicking the points on the map. This will populate a box in the upper right hand corner with metadata about which receivers have been deployed at that location and when the latest detection occurred. A plot of the number of daily detections at each location will show up in the right panel. A grey rectangle is displayed behind these detections to show when there was an active deployment at the location; this will not be very apparent if there are no gaps in coverage but will show them if they occurred.</p>
</section>
</section>
<section id="interactive-features" class="level2">
<h2 class="anchored" data-anchor-id="interactive-features">Interactive Features</h2>
</section>
<section id="panels" class="level2">
<h2 class="anchored" data-anchor-id="panels">Panels</h2>
<p>All panels can be expanded to full screen by clicking on the icon in lower right hand corner. These can be collapsed back to their originaly size either by clicking the “Close” button in the upper right hand corner or pressing the “Esc” button.</p>
<section id="maps" class="level3">
<h3 class="anchored" data-anchor-id="maps">Maps</h3>
<p>All map panels allow zooming by using the button in the upper left corner or using the scroll wheel on your mouse. Different base layers are available for toggling from the menu in the upper right hand corner. On regional occupancy maps, the various regions can be clicked to view the occupancy estimate.</p>
</section>
<section id="plots" class="level3">
<h3 class="anchored" data-anchor-id="plots">Plots</h3>
<p>All plotted objects have metadata that appears when the mouse cursor is hovered over them. There are a number of interactive options that appear in the upper right hand corner. Zoom to various regions of the plots using the buttons in that menu or by drawing a rectangle around the region of interest. After zooming, to return to the original view either press the “reset axes” button which looks like a house, or double click within the plot. For stacked bar charts, toggling to “Compare data on hover” can be a useful feature as the popup metadata will appear for each portion of the stacked bar. Various legend items can be isolated by double clicking in the legend. For example, to view just one location in the Explore Individuals Daily Detection Count plot, double click on one location in the legend, and double click again to restore all groups. Similarly, individual groups can be toggle on or off with a single click in the legend.</p>
</section>
</section>
<section id="estimation-methods" class="level2">
<h2 class="anchored" data-anchor-id="estimation-methods">Estimation Methods</h2>
<p>Two main metrics are reported in this app for visualization purposes, regional occupancy and depth distribution</p>
<section id="regional-occupancy" class="level3">
<h3 class="anchored" data-anchor-id="regional-occupancy">Regional Occupancy</h3>
<p>The starting point for this estimate was detections of individuals that have been screened for potential false, singleton detections. Those are detections that occur in isolation from any others for a transmitter/receiver combination; the criteria used here for isolation were those that did not have any other detections for that combination within 30x the nominal delay of the transmitter. So, for a transmitter with a nominal delay of 180 s that would mean a “singleton” detection is one that had no others at that transmitter/receiver combination within 5400 s (i.e.&nbsp;30 X 180). All of these flagged singleton detections were dropped from further analysis.</p>
<p>Filtered detections were then used to interpolated hourly detections. All detection time stamps were rounded to the nearest hour, and on hours when the fish was actually detected they were assigned to that location. If detected at multiple locations within the same hour, the first location was used. For hours during which an individual was not observed two options existed. First, if their next actual detection was at the same location as the previous then they were assumed to have not moved. Second, if if their next actual detection was at a different location then they’re assumed to have moved at a constant rate across the hours they were at large; so, with those a rate of travel was calculated and used to estimate how far along the least cost path (i.e.&nbsp;staying within the water) between the two receiver the fish was at any hour time step and snapped to the nearest 0.1 km based on that estimate. The network of 0.1 km points along least cost paths was also joined to region polygons so each of these interpolated points was associated with a region.</p>
<p>Regional occupancy was quantified using a time-weighted approach based on inferred hourly locations. For each individual and day, the number of hours inferred in each region was divided by 24 to yield fish-days per region, such that each active individual contributed one fish-day per calendar day it was active. Daily regional fish-days were then summed across individuals to calculate the proportion of total active fish-days occurring in each region on that day. Monthly regional occupancy was calculated as the mean of daily regional proportions across all days within the selected months and years. This equal-day weighting approach prevents days with larger numbers of active fish from disproportionately influencing monthly summaries. Final regional proportions were scaled to sum to one across regions.</p>
</section>
<section id="depth-distribution" class="level3">
<h3 class="anchored" data-anchor-id="depth-distribution">Depth Distribution</h3>
<p>Depth analysis was restricted to fish-days with detections occurring during at least three unique hours to ensure minimum temporal coverage. To reduce the influence of temporal autocorrelation associated with repeated detections, depth observations were summarized at an hourly time step by calculating the median depth for each individual within each hour. Hourly median depths were assigned to predefined depth bins, and depth use was summarized at the individual-month level as the proportion of observed hours spent within each depth bin. These proportions were calculated by dividing the number of hours an individual’s hourly median depth fell within a given depth bin by the total number of observed hours for that individual within the month. Population-level monthly depth distributions were then obtained by averaging individual-level proportions across all individuals observed within each month.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>